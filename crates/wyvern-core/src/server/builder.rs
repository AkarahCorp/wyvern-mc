use std::{collections::HashMap, ops::Deref, sync::Arc, thread::Builder, time::Instant};

use voxidian_protocol::autogenerated::block_states::{
    BLOCK_STATE_DEFAULTS, BLOCK_STATE_TO_ID, BLOCK_STATES, ID_TO_BLOCK_STATE,
};
use wyvern_textures::TexturePack;

use crate::{
    actors::ActorResult,
    blocks::BLOCK_STATE_KEYS,
    events::{Event, EventBus},
    plugin::Plugin,
};

use super::{ServerData, dimensions::DimensionContainer, registries::RegistryContainer};

pub struct ServerBuilder {
    events: EventBus,
    registries: RegistryContainer,
    dimensions: DimensionContainer,
    mojauth_enabled: bool,
    texture_pack: Option<TexturePack>,
    task_threads: usize,
}

impl Default for ServerBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ServerBuilder {
    pub fn new() -> ServerBuilder {
        ServerBuilder {
            events: EventBus::default(),
            registries: RegistryContainer::new(),
            dimensions: DimensionContainer {
                dimensions: HashMap::new(),
            },
            mojauth_enabled: true,
            texture_pack: None,
            task_threads: 1,
        }
    }

    pub fn event<
        E: Event + 'static,
        F: 'static + Future<Output = ActorResult<()>> + Send + Sync,
        N: 'static + Fn(Arc<E>) -> F + Send + Sync,
    >(
        mut self,
        f: N,
    ) -> Self {
        E::add_handler(&mut self.events, f);

        self
    }

    pub fn task_threads(mut self, threads: usize) -> Self {
        self.task_threads = threads;
        self
    }

    pub fn plugin<P: Plugin + 'static>(self, plugin: P) -> Self {
        plugin.build(self)
    }

    pub fn mojauth_enabled(mut self, status: bool) -> Self {
        self.mojauth_enabled = status;
        self
    }

    pub fn registries<F: FnOnce(&mut RegistryContainer)>(mut self, f: F) -> Self {
        f(&mut self.registries);
        self
    }

    pub fn pack(mut self, pack: TexturePack) -> Self {
        self.texture_pack = Some(pack);
        self
    }

    pub fn run(self) {
        let chan = flume::unbounded();
        let server = ServerData {
            connections: Vec::new(),
            registries: Arc::new(self.registries),
            dimensions: self.dimensions,
            last_tick: Instant::now(),

            sender: chan.0,
            receiver: chan.1,
            events: Arc::new(self.events),

            last_entity_id: 0,
            mojauth_enabled: self.mojauth_enabled,
            texture_pack: self.texture_pack.map(Arc::new),
        };

        log::info!("Initializing some lazy values...");

        let _ = BLOCK_STATES.deref();
        let _ = BLOCK_STATE_DEFAULTS.deref();
        let _ = BLOCK_STATE_TO_ID.deref();
        let _ = ID_TO_BLOCK_STATE.deref();
        let _ = BLOCK_STATE_KEYS.deref();

        for _ in 0..self.task_threads {
            let _ = Builder::new().name("AsyncEventLoop".into()).spawn(|| {
                loop {
                    futures::executor::block_on(crate::runtime::GLOBAL_EXECUTOR.tick())
                }
            });
        }

        server.start();
    }
}
