mod properties;
pub use properties::*;
mod components;
pub use components::*;

use std::collections::HashSet;
use std::sync::LazyLock;

use voxidian_protocol::autogenerated::block_states::{
    BLOCK_STATE_DEFAULTS, BLOCK_STATE_TO_ID, BLOCK_STATES, ID_TO_BLOCK_STATE,
};
use voxidian_protocol::value::BlockState as ProtocolState;

use crate::components::{DataComponentHolder, DataComponentMap};
use crate::values::Id;

pub static BLOCK_STATE_KEYS: LazyLock<HashSet<Id>> = LazyLock::new(|| {
    let mut set = HashSet::new();
    for state in BLOCK_STATES.iter().map(|x| x.block_state.id.clone()) {
        set.insert(state.into());
    }
    set
});

pub struct Block {}

#[derive(Debug, Clone)]
pub struct BlockState {
    pub(crate) block: Id,
    pub(crate) components: DataComponentMap,
}

#[allow(unused)]
fn components_to_array(components: &DataComponentMap) -> Vec<(String, String)> {
    let mut arr = Vec::new();
    // The keys of the matches *must* be in alphabetical order.
    if let Ok(value) = components.get(BlockComponents::SNOWY) {
        arr.push(("snowy", value.to_string()));
    }
    arr.into_iter().map(|x| (x.0.to_string(), x.1)).collect()
}

#[allow(unused)]
fn array_to_components(array: &[(String, String)]) -> DataComponentMap {
    let mut map = DataComponentMap::new();
    for element in array {
        #[allow(clippy::single_match)]
        match element.0.as_str() {
            "snowy" => {
                if let Ok(value) = element.1.parse::<bool>() {
                    map.set(BlockComponents::SNOWY, value)
                }
            }
            _ => {}
        }
    }
    map
}

impl DataComponentHolder for BlockState {
    fn component_map(&self) -> &DataComponentMap {
        &self.components
    }

    fn component_map_mut(&mut self) -> &mut DataComponentMap {
        &mut self.components
    }
}

impl BlockState {
    pub fn new(id: Id) -> BlockState {
        BlockState {
            block: id,
            components: DataComponentMap::new(),
        }
        .as_valid()
    }

    pub fn name(&self) -> &Id {
        &self.block
    }

    pub fn protocol_id(&self) -> i32 {
        *BLOCK_STATE_TO_ID.get(&self.into()).unwrap_or(&0)
    }

    pub fn from_protocol_id(id: i32) -> Self {
        Self::from(
            ID_TO_BLOCK_STATE
                .get(&id)
                .unwrap_or(ID_TO_BLOCK_STATE.get(&0).unwrap()),
        )
    }

    pub fn id_is_valid(&self) -> bool {
        BLOCK_STATE_DEFAULTS.contains_key(&self.block.clone().into())
    }

    pub fn as_valid(&self) -> Self {
        let mut underlying = ProtocolState {
            id: self.block.clone().into(),
            properties: components_to_array(&self.components),
        };
        let _ = underlying.make_valid();
        BlockState {
            block: underlying.id.into(),
            components: array_to_components(&underlying.properties),
        }
    }
}

impl From<&ProtocolState> for BlockState {
    fn from(value: &ProtocolState) -> Self {
        BlockState {
            block: value.id.clone().into(),
            components: array_to_components(&value.properties),
        }
    }
}

impl From<&BlockState> for ProtocolState {
    fn from(value: &BlockState) -> Self {
        ProtocolState {
            id: value.block.clone().into(),
            properties: components_to_array(&value.components),
        }
    }
}

pub struct Blocks;
wyvern_macros::generate_blocks_types!();
